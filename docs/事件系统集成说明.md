# 事件系统集成说明

## 概述

本次重构将 `eventSystem` 集成到 `app` 对象中，并将快捷键事件统一到事件系统中，实现了更加统一和类型安全的事件管理方式。

## 主要变更

### 1. 新增事件管理器类

创建了 `src/renderer/src/core/modules/event.ts`，使用单例模式实现事件管理：

- **不使用 Pinia**：事件系统是一个纯粹的事件发布订阅系统，不需要响应式状态管理
- **单例模式**：导出 `appEventManager` 实例，全局唯一
- **类实现**：使用 `AppEventManager` 类封装 mitt 事件发射器
- **完整功能**：
  - `on(type, handler)` - 监听事件
  - `off(type, handler)` - 取消监听
  - `emit(type, event)` - 触发事件
  - `once(type, handler)` - 一次性监听
  - `clear()` - 清除所有监听器

### 2. 集成到 App Store

在 `src/renderer/src/core/index.ts` 中直接引用 `appEventManager` 实例：

```ts
import { appEventManager } from "./modules/event";

export const useApp = defineStore("app", () => {
  // ...
  const event = appEventManager; // 直接引用单例实例

  return {
    // ...
    event,
  };
});

// 使用方式
const app = useApp();
app.event.on("hotkey:triggered", handler);
app.event.on("plugin:executed", handler);
```

### 3. 快捷键事件迁移

#### 事件类型定义更新

在 `src/renderer/src/utils/eventSystem.ts` 的 `AppEvents` 接口中添加了快捷键事件：

```ts
export interface AppEvents {
  // 快捷键相关事件
  "hotkey:triggered": {
    id: string;
    config: HotkeyConfig;
    type: HotkeyType;
  };
  // ... 其他事件
}
```

#### 触发方式更新

在 `src/renderer/src/core/utils/hotkey.ts` 中，`triggerHotkeyEvent` 函数从使用 DOM CustomEvent 改为使用 appEventManager：

**旧方式（DOM CustomEvent）：**

```ts
const customEvent = new CustomEvent("hotkey-triggered", {
  detail: eventDetail,
});
window.dispatchEvent(customEvent);
```

**新方式（appEventManager）：**

```ts
appEventManager.emit("hotkey:triggered", {
  id: config.id,
  config,
  type: config.type,
});
```

#### 移除 Hotkey Store 的事件方法

从 `src/renderer/src/core/modules/hotkey/index.ts` 中移除了 `on` 和 `off` 方法，添加了迁移说明：

````ts
/**
 * 快捷键事件监听已统一到 event 系统中
 *
 * 请使用以下方式监听快捷键事件：
 * ```ts
 * const app = useApp()
 * app.event.on('hotkey:triggered', (event) => {
 *   console.log('快捷键触发:', event.id)
 *   console.log('类型:', event.type) // HotkeyType.GLOBAL 或 HotkeyType.APPLICATION
 *   console.log('配置:', event.config)
 * })
 * ```
 */
````

### 4. App.vue 更新

更新了事件监听方式：

**旧方式：**

```ts
const eventSystem = useEventSystem();
app.hotkey.on("hotkey:triggered", onHotkeyTriggered);
eventSystem.on("plugin:executed", handlePluginExecuted);
```

**新方式：**

```ts
app.event.on("hotkey:triggered", onHotkeyTriggered);
app.event.on("plugin:executed", handlePluginExecuted);
```

同时更新了 `onHotkeyTriggered` 的参数类型，从 DOM CustomEvent 改为直接的事件数据对象：

```ts
const onHotkeyTriggered = async (event: {
  id: string;
  config: any;
  type: "global" | "application";
}) => {
  // 处理逻辑...
};
```

## 使用指南

### 方式一：通过 App Store 访问（推荐）

```ts
import { useApp } from "@/core";

const app = useApp();

// 监听快捷键触发
app.event.on("hotkey:triggered", (event) => {
  console.log("快捷键ID:", event.id);
  console.log("快捷键类型:", event.type); // HotkeyType.GLOBAL | HotkeyType.APPLICATION
  console.log("快捷键配置:", event.config);
});

// 监听插件执行
app.event.on("plugin:executed", (event) => {
  console.log("插件ID:", event.pluginId);
  console.log("插件路径:", event.path);
});

// 一次性监听
app.event.once("window:close-requested", () => {
  console.log("窗口关闭请求（只触发一次）");
});
```

### 方式二：直接使用事件管理器

```ts
import { appEventManager } from "@/core";
import type { AppEvents } from "@/core";

// 直接使用事件管理器（不需要通过 app store）
appEventManager.on("hotkey:triggered", (event) => {
  console.log("快捷键触发:", event.id);
});

// 使用类型进行类型安全的开发
type PluginEvent = AppEvents["plugin:executed"];
const handlePlugin = (event: PluginEvent) => {
  console.log(event.pluginId, event.path);
};
appEventManager.on("plugin:executed", handlePlugin);
```

### 触发事件

```ts
// 触发搜索清空事件
app.event.emit("search:clear");

// 触发窗口调整大小事件
app.event.emit("window:resize", {
  height: 500,
});
```

### 取消监听

```ts
const handler = (event) => {
  console.log("事件触发", event);
};

// 监听
app.event.on("plugin:executed", handler);

// 取消监听
app.event.off("plugin:executed", handler);
```

## 优势

1. **统一的API**：所有事件监听都通过 `app.event` 访问，接口一致
2. **类型安全**：通过 TypeScript 的类型定义，编译时即可检查事件类型和参数
3. **易于维护**：事件定义集中在 `AppEvents` 接口中，一目了然
4. **更好的解耦**：事件发布和订阅解耦，降低组件间的直接依赖
5. **集中管理**：所有应用事件（包括快捷键事件）都在一个系统中管理

## 架构设计

### 为什么不使用 Pinia？

事件系统使用单例类而不是 Pinia Store，原因如下：

1. **不需要响应式**：事件系统只是发布订阅模式，不需要 Vue 的响应式系统
2. **更轻量**：避免 Pinia 的额外开销，提升性能
3. **独立性强**：事件系统是独立的基础设施，不应该依赖于状态管理库
4. **简单直接**：单例模式更符合事件系统的使用场景

### 文件组织

- **删除了** `src/renderer/src/utils/eventSystem.ts`
- **类型定义**：`src/renderer/src/core/typings/event.ts` - 包含 `AppEvents`、`AppEventType`、`AppEventHandler`
- **实现代码**：`src/renderer/src/core/modules/event.ts` - 包含 `AppEventManager` 类和 `appEventManager` 实例
- **统一导出**：`src/renderer/src/core/index.ts` - 导出 `appEventManager` 和所有事件类型
- **全局统一使用** `appEventManager` 实例

## 向后兼容

- `useEventSystem` composable 已更新为使用 `appEventManager`，API 保持不变
- 所有依赖旧 `eventSystem` 的文件都已更新
- 事件名称和数据结构保持不变，只是底层实现更改

## 迁移检查清单

- [x] 创建 AppEventManager 类（单例模式）
- [x] 将类型定义移到 `core/typings/event.ts`
- [x] 集成到 App Store（直接引用实例，不使用 Pinia）
- [x] 更新 AppEvents 接口添加快捷键事件
- [x] 更新 triggerHotkeyEvent 使用 appEventManager
- [x] 移除 Hotkey Store 的 on/off 方法
- [x] 更新 App.vue 的事件监听方式
- [x] 更新 useAppActions.ts 使用 appEventManager
- [x] 删除旧的 utils/eventSystem.ts 文件
- [x] 删除 composables/useEventSystem.ts 文件（不再需要）
- [x] 删除 core/typings/hotkey.ts 中的 HotkeyEventType 和 HotkeyEventListener（已迁移到事件系统）
- [x] 删除 core/typings/hotkey.ts 中的 HotkeyEventDetail（不再使用）
- [x] 在 core/index.ts 中统一导出事件类型
- [x] 清理未使用的导入和变量
- [x] 所有 linter 错误已修复

## 清理工作

### 已删除的文件和类型

1. **删除的文件**：
   - `src/renderer/src/utils/eventSystem.ts` - 已整合到 core/modules/event.ts
   - `src/renderer/src/composables/useEventSystem.ts` - 不再需要，直接使用 app.event

2. **删除的类型定义**（从 core/typings/hotkey.ts）：
   - `HotkeyEventType` - 快捷键事件已迁移到 AppEvents
   - `HotkeyEventListener` - 事件监听器已统一到 AppEventHandler
   - `HotkeyEventDetail` - 事件详情已整合到 AppEvents['hotkey:triggered']

3. **保留的旧系统**：
   - `src/renderer/src/typings/hotkeyTypes.ts` 中的相关类型仍保留，供旧的 HotkeyManager 使用
   - 后续可以逐步迁移旧系统到新的 core 系统

## 使用建议

- ✅ **推荐**：使用 `app.event.on()` 或直接使用 `appEventManager`
- ❌ **不推荐**：不要再创建新的 useEventSystem 或类似的包装
- 💡 **提示**：所有事件监听都应该通过统一的事件系统进行
- 📌 **命名约定**：事件名称使用冒号 `:` 分隔，如 `hotkey:triggered`、`plugin:executed`、`window:resize` 等
