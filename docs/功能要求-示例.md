对于 Electron + Vue 中的全局搜索、全局快捷键、插件系统这些功能，我建议采用**分层混合架构**：底层 API + Pinia Store + Composables 的组合方案。

## 整体架构设计

### 架构分层

```
┌─────────────────────┐
│   Vue Components    │ ← 组件层，使用 composables
├─────────────────────┤
│   Composables       │ ← Vue 适配层，连接 Store 和 API
├─────────────────────┤
│   Pinia Stores      │ ← 状态管理层，管理响应式状态
├─────────────────────┤
│   Core APIs         │ ← 核心逻辑层，不依赖 Vue
├─────────────────────┤
│   Electron IPC      │ ← 进程通信层
└─────────────────────┘
```

## 具体设计方案

### 1. 全局搜索系统

**Core API (不依赖 Vue)**

```typescript
// src/core/search/SearchEngine.ts
export class SearchEngine {
  private searchIndex: Map<string, any> = new Map();
  private providers: SearchProvider[] = [];

  async search(
    query: string,
    options?: SearchOptions
  ): Promise<SearchResult[]> {
    // 核心搜索逻辑
  }

  registerProvider(provider: SearchProvider): void {
    this.providers.push(provider);
  }

  buildIndex(data: any[]): void {
    // 构建搜索索引
  }
}

export const searchEngine = new SearchEngine();
```

**Pinia Store (管理搜索状态)**

```typescript
// src/stores/searchStore.ts
export const useSearchStore = defineStore("search", () => {
  const query = ref("");
  const results = ref<SearchResult[]>([]);
  const isSearching = ref(false);
  const isVisible = ref(false);

  const search = async (searchQuery: string) => {
    isSearching.value = true;
    query.value = searchQuery;

    try {
      results.value = await searchEngine.search(searchQuery);
    } finally {
      isSearching.value = false;
    }
  };

  const showSearch = () => {
    isVisible.value = true;
  };

  const hideSearch = () => {
    isVisible.value = false;
    query.value = "";
    results.value = [];
  };

  return {
    query,
    results,
    isSearching,
    isVisible,
    search,
    showSearch,
    hideSearch,
  };
});
```

**Composable (Vue 适配层)**

```typescript
// src/composables/useSearch.ts
export const useSearch = () => {
  const searchStore = useSearchStore();

  const registerSearchData = (data: any[], type: string) => {
    searchEngine.registerProvider({
      type,
      search: (query) => searchInData(data, query),
    });
  };

  return {
    ...storeToRefs(searchStore),
    search: searchStore.search,
    showSearch: searchStore.showSearch,
    hideSearch: searchStore.hideSearch,
    registerSearchData,
  };
};
```

### 2. 全局快捷键系统

**Core API**

```typescript
// src/core/hotkey/HotkeyManager.ts
export class HotkeyManager {
  private shortcuts: Map<string, HotkeyHandler> = new Map();

  register(accelerator: string, handler: HotkeyHandler): void {
    this.shortcuts.set(accelerator, handler);
    // 通知主进程注册快捷键
    naimo.registerGlobalShortcut(accelerator);
  }

  unregister(accelerator: string): void {
    this.shortcuts.delete(accelerator);
    naimo.unregisterGlobalShortcut(accelerator);
  }

  execute(accelerator: string): void {
    const handler = this.shortcuts.get(accelerator);
    handler?.();
  }
}

export const hotkeyManager = new HotkeyManager();
```

**Pinia Store**

```typescript
// src/stores/hotkeyStore.ts
export const useHotkeyStore = defineStore("hotkey", () => {
  const registeredShortcuts = ref<Map<string, HotkeyConfig>>(new Map());

  const registerShortcut = (config: HotkeyConfig) => {
    registeredShortcuts.value.set(config.accelerator, config);
    hotkeyManager.register(config.accelerator, config.handler);
  };

  const unregisterShortcut = (accelerator: string) => {
    registeredShortcuts.value.delete(accelerator);
    hotkeyManager.unregister(accelerator);
  };

  return {
    registeredShortcuts: readonly(registeredShortcuts),
    registerShortcut,
    unregisterShortcut,
  };
});
```

**Composable**

```typescript
// src/composables/useHotkey.ts
export const useHotkey = () => {
  const hotkeyStore = useHotkeyStore();

  const registerHotkey = (
    accelerator: string,
    handler: () => void,
    options?: HotkeyOptions
  ) => {
    onMounted(() => {
      hotkeyStore.registerShortcut({
        accelerator,
        handler,
        ...options,
      });
    });

    onUnmounted(() => {
      if (!options?.persistent) {
        hotkeyStore.unregisterShortcut(accelerator);
      }
    });
  };

  return { registerHotkey };
};
```

### 3. 插件系统

**Core API**

```typescript
// src/core/plugin/PluginManager.ts
export class PluginManager {
  private plugins: Map<string, Plugin> = new Map();
  private hooks: Map<string, Function[]> = new Map();

  async loadPlugin(pluginPath: string): Promise<void> {
    const plugin = await import(pluginPath);
    this.plugins.set(plugin.id, plugin);
    await plugin.activate?.(this.createPluginAPI());
  }

  unloadPlugin(pluginId: string): void {
    const plugin = this.plugins.get(pluginId);
    plugin?.deactivate?.();
    this.plugins.delete(pluginId);
  }

  registerHook(event: string, handler: Function): void {
    if (!this.hooks.has(event)) {
      this.hooks.set(event, []);
    }
    this.hooks.get(event)!.push(handler);
  }

  executeHook(event: string, ...args: any[]): void {
    this.hooks.get(event)?.forEach((handler) => handler(...args));
  }

  private createPluginAPI() {
    return {
      registerCommand: (command: Command) => {
        /* ... */
      },
      registerView: (view: ViewConfig) => {
        /* ... */
      },
      onHook: this.registerHook.bind(this),
    };
  }
}

export const pluginManager = new PluginManager();
```

**Pinia Store**

```typescript
// src/stores/pluginStore.ts
export const usePluginStore = defineStore("plugin", () => {
  const plugins = ref<Map<string, PluginInfo>>(new Map());
  const isLoading = ref(false);

  const loadPlugin = async (pluginPath: string) => {
    isLoading.value = true;
    try {
      await pluginManager.loadPlugin(pluginPath);
      // 更新插件列表状态
    } finally {
      isLoading.value = false;
    }
  };

  const unloadPlugin = (pluginId: string) => {
    pluginManager.unloadPlugin(pluginId);
    plugins.value.delete(pluginId);
  };

  return {
    plugins: readonly(plugins),
    isLoading: readonly(isLoading),
    loadPlugin,
    unloadPlugin,
  };
});
```

**Composable**

```typescript
// src/composables/usePlugin.ts
export const usePlugin = () => {
  const pluginStore = usePluginStore();

  const usePluginHook = (event: string, handler: Function) => {
    onMounted(() => {
      pluginManager.registerHook(event, handler);
    });
  };

  return {
    ...storeToRefs(pluginStore),
    loadPlugin: pluginStore.loadPlugin,
    unloadPlugin: pluginStore.unloadPlugin,
    usePluginHook,
  };
};
```

## 使用方式示例

### 在组件中使用

```vue
<template>
  <div>
    <GlobalSearch v-if="searchVisible" />
  </div>
</template>

<script setup lang="ts">
// 使用搜索功能
const { searchVisible, showSearch, registerSearchData } = useSearch();

// 注册快捷键
const { registerHotkey } = useHotkey();
registerHotkey("CmdOrCtrl+K", showSearch);

// 使用插件系统
const { usePluginHook } = usePlugin();
usePluginHook("file-opened", (filePath) => {
  console.log("File opened:", filePath);
});

// 注册组件数据到搜索引擎
onMounted(() => {
  registerSearchData(myData.value, "component-data");
});
</script>
```

## 为什么选择这种架构？

### 优势

1. **关注点分离**：核心逻辑独立于 Vue，便于测试和复用
2. **响应式管理**：Pinia 负责需要响应式的全局状态
3. **组合便利性**：Composables 提供 Vue 友好的接口
4. **扩展性好**：可以轻松添加新功能或替换实现
5. **类型安全**：全程 TypeScript 支持

### 层次职责

- **Core API**：处理核心逻辑、Electron 通信、不依赖框架
- **Pinia Store**：管理需要跨组件共享的响应式状态
- **Composables**：提供 Vue 组件友好的接口，处理生命周期

### 适用场景

- ✅ 需要跨组件使用的功能
- ✅ 涉及 Electron 主/渲染进程通信
- ✅ 需要全局状态管理
- ✅ 希望核心逻辑独立可测试

这样的架构既保证了功能的全局可用性，又保持了良好的可维护性和可测试性。
