# Vue 组件创建指南

## 概述

本文档详细说明了在 Naimo 项目中创建 Vue 组件的规范和方法。项目基于 Vue 3 + TypeScript + TailwindCSS 技术栈，集成了完整的 IPC 通信系统和自动导入功能。

## 技术栈

- **Vue 3**: 使用 Composition API 和 `<script setup>` 语法
- **TypeScript**: 完整的类型安全支持
- **TailwindCSS**: 原子化 CSS 框架
- **自动导入**: Vue APIs、组件、图标等自动导入
- **IPC 通信**: 类型安全的主进程通信

## 组件基本结构

### 1. 组件文件结构

```vue
<template>
  <!-- 模板内容 -->
</template>

<script setup lang="ts">
// 脚本内容
</script>

<style scoped lang="scss">
@reference "@/style.css";
/* 样式内容 */
</style>
```

### 2. 基本组件示例

```vue
<template>
  <!-- 主容器 -->
  <div class="my-component">
    <!-- 标题区域 -->
    <h2 class="text-2xl font-bold text-gray-800 mb-4">
      {{ title }}
    </h2>

    <!-- 操作按钮区域 -->
    <button
      @click="handleClick"
      class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
    >
      <IconMdiPlus class="v-icon mr-2" />
      点击我
    </button>
  </div>
</template>

<script setup lang="ts">
// 定义 Props
interface Props {
  title: string;
  count?: number;
}

const props = withDefaults(defineProps<Props>(), {
  count: 0,
});

// 定义 Emits
interface Emits {
  update: [value: number];
}

const emit = defineEmits<Emits>();

// 响应式数据
const localCount = ref(props.count);

// 计算属性
const displayText = computed(() => `当前计数: ${localCount.value}`);

// 方法
const handleClick = async () => {
  localCount.value++;
  emit("update", localCount.value);

  // 记录日志
  api.log.info("按钮被点击", { count: localCount.value });
};

// 生命周期
onMounted(() => {
  console.log("组件已挂载");
});
</script>

<style scoped lang="scss">
@reference "@/style.css";

/* 主组件容器样式 */
.my-component {
  @apply p-6 bg-white rounded-lg shadow-md;

  /* 标题样式 */
  h2 {
    @apply text-2xl font-bold text-gray-800 mb-4;
  }
}
</style>
```

## 开发规范

### 1. 脚本规范

#### 使用 `<script setup>` 语法

```vue
<script setup lang="ts">
// ✅ 推荐：使用 setup 语法
const count = ref(0);
</script>
```

#### TypeScript 类型定义

```vue
<script setup lang="ts">
// ✅ 推荐：定义接口
interface User {
  id: number;
  name: string;
  email: string;
}

// ✅ 推荐：使用 withDefaults
interface Props {
  user: User;
  showEmail?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  showEmail: false,
});

// ✅ 推荐：定义 Emits 类型
interface Emits {
  update: [user: User];
  delete: [id: number];
}

const emit = defineEmits<Emits>();
</script>
```

### 2. 样式规范

#### 使用 TailwindCSS

**重要规则：TailwindCSS 样式尽可能写在元素上，只有一些特殊的样式可以写在 style 中**

```vue
<template>
  <!-- ✅ 推荐：TailwindCSS 样式直接写在元素上 -->
  <div
    class="flex items-center justify-between p-4 bg-white rounded-lg shadow-md"
  >
    <!-- 标题区域 -->
    <h3 class="text-lg font-semibold text-gray-800">标题</h3>

    <!-- 操作按钮区域 -->
    <button
      class="px-3 py-1 text-sm bg-blue-500 text-white rounded hover:bg-blue-600"
    >
      按钮
    </button>
  </div>
</template>

<style scoped>
@reference "@/style.css";

/* ✅ 只保留特殊样式，如 -webkit-app-region 等无法通过 TailwindCSS 实现的样式 */
.drag-area {
  -webkit-app-region: drag;
}

.no-drag-area {
  -webkit-app-region: no-drag;
}
</style>
```

**TailwindCSS 使用原则：**

1. **优先使用内联类名**：所有 TailwindCSS 样式都应该直接写在元素的 `class` 属性中
2. **避免在 style 中使用 @apply**：除非是复杂的嵌套样式或特殊需求
3. **特殊样式例外**：只有以下情况可以在 style 中写样式：
   - `-webkit-app-region` 等浏览器特定属性
   - CSS 变量和自定义属性
   - 复杂的动画和过渡效果
   - 无法用 TailwindCSS 表达的样式

```vue
<!-- ✅ 正确示例 -->
<template>
  <div
    class="w-full h-full bg-gray-100 flex flex-col"
    style="-webkit-app-region: drag;"
  >
    <div
      class="flex justify-end items-center h-8 bg-gray-200 px-2"
      style="-webkit-app-region: no-drag;"
    >
      <button
        class="w-6 h-6 flex items-center justify-center text-gray-600 hover:text-gray-800 hover:bg-gray-300 transition-colors duration-200"
      >
        按钮
      </button>
    </div>
  </div>
</template>

<!-- ❌ 错误示例 -->
<template>
  <div class="app-container">
    <div class="window-controls">
      <button class="window-control-button">按钮</button>
    </div>
  </div>
</template>

<style scoped>
.app-container {
  @apply w-full h-full bg-gray-100 flex flex-col;
}

.window-controls {
  @apply flex justify-end items-center h-8 bg-gray-200 px-2;
}

.window-control-button {
  @apply w-6 h-6 flex items-center justify-center text-gray-600 hover:text-gray-800 hover:bg-gray-300 transition-colors duration-200;
}
</style>
```

#### 使用 Sass 预处理器

**注意：根据新的 TailwindCSS 规则，应该优先使用内联类名，Sass 主要用于特殊样式**

```vue
<!-- 不要加 lang="scss" -->
<style scoped>
// 必须引入
@reference "@/style.css";

/* ✅ 推荐：只用于特殊样式，如复杂的动画、CSS 变量等 */
.my-component {
  /* 复杂的动画效果 */
  animation: slideIn 0.3s ease-in-out;

  /* CSS 变量 */
  --custom-color: #3b82f6;

  /* 浏览器特定属性 */
  -webkit-app-region: drag;
}

/* 复杂动画定义 */
@keyframes slideIn {
  from {
    transform: translateX(-100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

/* ❌ 不推荐：简单的 TailwindCSS 样式应该写在元素上 */
.old-style {
  @apply p-4 bg-white rounded-lg;
}
</style>
```

**Sass 使用原则：**

1. **主要用于特殊样式**：复杂的动画、CSS 变量、浏览器特定属性等
2. **避免简单的 @apply**：简单的 TailwindCSS 样式应该直接写在元素上
3. **保持简洁**：style 部分应该尽可能简洁，大部分样式通过内联类名实现

### 3. 图标使用规范

#### 使用 MDI 图标

```vue
<template>
  <!-- ✅ 推荐：TailwindCSS 样式直接写在元素上 -->
  <div class="flex items-center space-x-2">
    <IconMdiHome class="w-5 h-5 text-gray-600" />
    <IconMdiAccountCircle class="w-5 h-5 text-gray-600" />
    <IconMdiSettings class="w-5 h-5 text-gray-600" />
  </div>
</template>

<style scoped>
@reference "@/style.css";

/* ✅ 只保留特殊样式，如复杂的图标动画等 */
.icon-container {
  /* 复杂的图标动画 */
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}
</style>
```

**图标使用原则：**

1. **直接使用 TailwindCSS 类名**：图标的尺寸、颜色等样式直接写在 `class` 属性中
2. **常用图标尺寸**：
   - `w-4 h-4` - 小图标 (16px)
   - `w-5 h-5` - 标准图标 (20px)
   - `w-6 h-6` - 大图标 (24px)
3. **常用图标颜色**：
   - `text-gray-600` - 默认颜色
   - `text-blue-600` - 主要颜色
   - `text-red-600` - 警告颜色

## IPC 通信使用

### 1. 基本用法

```vue
<script setup lang="ts">
// ✅ 推荐：使用 api.ipcRouter 调用 IPC 方法
const getAppInfo = async () => {
  try {
    const version = await api.ipcRouter.appGetVersion();
    const name = await api.ipcRouter.appGetName();
    console.log(`应用: ${name} v${version}`);
  } catch (error) {
    console.error("获取应用信息失败:", error);
  }
};

// ✅ 推荐：使用配置存储
const saveUserSettings = async () => {
  try {
    await api.ipcRouter.storeSet("theme", "dark");
    await api.ipcRouter.storeSet("language", "zh-CN");
    console.log("设置已保存");
  } catch (error) {
    console.error("保存设置失败:", error);
  }
};
</script>
```

### 2. 可用的 IPC 方法

#### 应用管理 (app)

```typescript
// 获取应用信息
const version = await api.ipcRouter.appGetVersion();
const name = await api.ipcRouter.appGetName();
const path = await api.ipcRouter.appGetAppPath();
const userDataPath = await api.ipcRouter.appGetUserDataPath();
const isPackaged = await api.ipcRouter.appIsPackaged();
const systemInfo = await api.ipcRouter.appGetSystemInfo();
const config = await api.ipcRouter.appGetConfig();

// 应用控制
await api.ipcRouter.appShowAbout();
await api.ipcRouter.appRestart();
await api.ipcRouter.appQuit();
```

#### 文件系统 (filesystem)

```typescript
// 文件选择
const files = await api.ipcRouter.filesystemSelectFile({
  title: "选择文件",
  filters: [
    { name: "图片", extensions: ["jpg", "png", "gif"] },
    { name: "所有文件", extensions: ["*"] },
  ],
});

// 文件夹选择
const folders = await api.ipcRouter.filesystemSelectFolder({
  title: "选择文件夹",
});

// 保存文件
const savePath = await api.ipcRouter.filesystemSaveFile({
  title: "保存文件",
  defaultPath: "untitled.txt",
  filters: [{ name: "文本文件", extensions: ["txt"] }],
});
```

#### 日志管理 (log)

```typescript
// 获取日志
const logs = await api.ipcRouter.logGetLogs();
const rawContent = await api.ipcRouter.logGetRawLogContent();
const logInfo = await api.ipcRouter.logGetLogInfo();

// 日志操作
await api.ipcRouter.logClearLogs();
const exportedTxt = await api.ipcRouter.logExportLogs("txt");
const exportedJson = await api.ipcRouter.logExportLogs("json");
```

#### 存储管理 (store)

```typescript
// 获取配置
const theme = await api.ipcRouter.storeGet("theme");
const allConfig = await api.ipcRouter.storeGet(); // 获取所有配置

// 设置配置
await api.ipcRouter.storeSet("theme", "dark");
await api.ipcRouter.storeSet("language", "zh-CN");

// 删除配置
await api.ipcRouter.storeDeleteKey("theme");

// 清空配置
await api.ipcRouter.storeClear();
```

#### 窗口管理 (window)

```typescript
// 窗口控制
await api.ipcRouter.windowMinimize();
await api.ipcRouter.windowMaximize();
await api.ipcRouter.windowClose();

// 窗口状态
const isMaximized = await api.ipcRouter.windowIsMaximized();

// 打开日志查看器
await api.ipcRouter.windowOpenLogViewer();
```

### 3. 错误处理

```vue
<script setup lang="ts">
const handleApiCall = async () => {
  try {
    const result = await api.ipcRouter.appGetVersion();
    console.log("成功:", result);
  } catch (error) {
    console.error("API 调用失败:", error);
    // 显示用户友好的错误信息
    message.value = "操作失败，请重试";
  }
};
</script>
```

## 自动导入功能

### 1. Vue APIs 自动导入

```vue
<script setup lang="ts">
// ✅ 无需导入，直接使用
const count = ref(0);
const doubled = computed(() => count.value * 2);
const router = useRouter();
const route = useRoute();

// 生命周期
onMounted(() => {
  console.log("组件已挂载");
});

// 监听器
watch(count, (newVal) => {
  console.log("计数变化:", newVal);
});
</script>
```

### 2. VueUse 工具函数

```vue
<script setup lang="ts">
// ✅ 无需导入，直接使用
const { copy } = useClipboard();
const isDark = useDark();
const { x, y } = useMouse();
const { width, height } = useWindowSize();
</script>
```

### 3. 组件自动导入

```vue
<template>
  <!-- 组件容器 -->
  <div class="components-container">
    <!-- 自定义组件 -->
    <MyCustomComponent />

    <!-- 用户资料组件 -->
    <UserProfile />

    <!-- 数据表格组件 -->
    <DataTable />
  </div>
</template>

<style scoped>
/* 组件容器样式 */
.components-container {
  @apply space-y-4 p-4;
}
</style>
```

## 最佳实践

### 1. 组件设计原则

#### 单一职责

```vue
<!-- 用户卡片组件 -->
<template>
  <!-- 用户卡片容器 -->
  <div class="user-card">
    <!-- 用户头像区域 -->
    <UserAvatar :user="user" />

    <!-- 用户信息区域 -->
    <UserInfo :user="user" />

    <!-- 用户操作区域 -->
    <UserActions :user="user" @edit="handleEdit" />
  </div>
</template>
```

#### 可复用性

```vue
<script setup lang="ts">
// ✅ 推荐：通过 props 和 events 实现可复用
interface Props {
  title: string;
  variant?: "primary" | "secondary";
  disabled?: boolean;
}

interface Emits {
  click: [event: MouseEvent];
}

const props = withDefaults(defineProps<Props>(), {
  variant: "primary",
  disabled: false,
});

const emit = defineEmits<Emits>();
</script>
```

### 2. 性能优化

#### 使用 computed 和 watch

```vue
<script setup lang="ts">
// ✅ 推荐：使用 computed 缓存计算结果
const filteredItems = computed(() => items.value.filter((item) => item.active));

// ✅ 推荐：使用 watch 监听变化
watch(
  filteredItems,
  (newItems) => {
    console.log("过滤后的项目数量:", newItems.length);
  },
  { deep: true }
);
</script>
```

#### 懒加载组件

```vue
<script setup lang="ts">
// ✅ 推荐：懒加载大型组件
const HeavyComponent = defineAsyncComponent(
  () => import("./HeavyComponent.vue")
);
</script>
```

### 3. 代码组织

#### 按功能分组

```vue
<script setup lang="ts">
// ==================== Props & Emits ====================
interface Props {
  // ...
}
const props = defineProps<Props>();
const emit = defineEmits<Emits>();

// ==================== 响应式数据 ====================
const count = ref(0);
const message = ref("");

// ==================== 计算属性 ====================
const displayText = computed(() => {
  // ...
});

// ==================== 方法 ====================
const handleClick = () => {
  // ...
};

// ==================== 生命周期 ====================
onMounted(() => {
  // ...
});
</script>
```

### 4. 错误处理

#### 全局错误处理

```vue
<script setup lang="ts">
const handleAsyncOperation = async () => {
  try {
    const result = await api.ipcRouter.appGetVersion();
    return result;
  } catch (error) {
    console.error("操作失败:", error);
    // 记录错误日志
    api.log.error("获取版本失败", error);
    throw error;
  }
};
</script>
```

## 调试技巧

### 1. 使用 Vue DevTools

- 安装 Vue DevTools 浏览器扩展
- 在开发模式下自动启用
- 可以查看组件状态、props、events 等

### 2. 控制台调试

```vue
<script setup lang="ts">
// ✅ 推荐：使用 console.log 调试
const debugInfo = () => {
  console.log("组件状态:", {
    count: count.value,
    message: message.value,
    props: props,
  });
};

// ✅ 推荐：使用 api.log 记录日志
const logUserAction = (action: string) => {
  api.log.info("用户操作", { action, timestamp: Date.now() });
};
</script>
```

### 3. 断点调试

- 在 VS Code 中设置断点
- 使用 F5 启动调试会话
- 支持条件断点和日志断点

## 常见问题

### Q: 如何添加新的 IPC 方法？

A: 在 `src/main/ipc-router/modules/` 下创建或编辑模块文件，运行 `pnpm generate:ipc-types` 重新生成类型。

### Q: 组件样式不生效怎么办？

A: 确保在 `<style>` 标签中引入了 `@reference "@/style.css"`，并且使用了正确的 TailwindCSS 类名。

### Q: 如何调试 IPC 通信？

A: 使用 `api.log` 记录日志，或者在主进程中使用 `console.log` 查看调用情况。

### Q: 自动导入不工作怎么办？

A: 检查 `vite.config.ts` 配置，确保自动导入插件正确配置，并重启开发服务器。

## 参考资源

- [Vue 3 官方文档](https://vuejs.org/)
- [TypeScript 官方文档](https://www.typescriptlang.org/)
- [TailwindCSS 官方文档](https://tailwindcss.com/)
- [VueUse 官方文档](https://vueuse.org/)
- [项目概览文档](../docs/项目概览.md)
- [前端部署文档](../docs/前端部署文档.md)
