# 组件和事件监听重构说明

## 重构时间

2025年10月5日

## 重构目标

1. 简化 App.vue，减少组件臃肿
2. 改善组件结构，将大组件拆分为小组件
3. 移除不必要的事件监听包装层
4. 将组件特定的 hooks 移至组件目录下，便于管理

## 主要变更

### 1. 组件拆分

#### SearchHeader 组件结构

```
components/SearchHeader/
├── SearchHeader.vue          # 主组件
├── components/
│   ├── PluginInfoDisplay.vue # 插件信息显示
│   ├── FileInfoDisplay.vue   # 文件信息显示
│   ├── DragIcon.vue          # 拖拽图标
│   └── SettingsButton.vue    # 设置按钮
└── hooks/
    ├── useSearchHeaderState.ts # 搜索头部状态管理
    └── useFilePaste.ts         # 文件粘贴处理
```

**优势：**

- 每个子组件职责单一，易于理解和维护
- 组件特定的 hooks 就近放置，便于查找
- 提高了代码复用性

### 2. 事件监听简化

#### 废弃的文件

- `src/renderer/src/composables/useAppEventHandlers.ts` - 已标记为 `@deprecated`

**原因：**

- 创建了过多的包装函数（`createWindowFocusHandlers`、`createSearchHandlers` 等）
- 增加了不必要的抽象层，使代码追踪变得困难
- 事件处理逻辑分散在多个文件中

**新方案：**
在 `App.vue` 中直接注册事件监听：

```typescript
// 直接注册窗口事件
naimo.event.onAppFocus((event, data) => {
  onWindowFocus();
});

naimo.event.onAppBlur((event, data) => {
  onWindowBlur(data);
});

// 直接注册主进程事件
naimo.event.onPluginWindowClosed((event, data) => {
  handlePluginWindowClosed(data);
});
```

### 3. useAppLifecycle 简化

#### 变更前

```typescript
// 包含大量包装函数
const {
  initializeApp,
  registerWindowEventListeners,
  registerMainProcessEventListeners,
  registerHotkeyEventListeners,
} = useAppLifecycle();

// 需要传入大量的 handlers
await initializeApp({
  onWindowFocus,
  onWindowBlur,
  onVisibilityChange,
  // ... 更多 handlers
});
```

#### 变更后

```typescript
// 只负责应用初始化，不管理事件注册
const { uiConstants, initializeApp } = useAppLifecycle();

// 简单的初始化调用
await initializeApp();

// 事件监听在 App.vue 中直接注册
```

### 4. App.vue 结构优化

#### 优化前

- 700+ 行代码
- 10+ 个 hooks 导入
- 复杂的事件处理器创建逻辑
- 难以追踪事件流

#### 优化后

- 使用 SearchHeader 组件替代原有的搜索头部模板代码
- 直接在 onMounted 中注册事件监听
- 事件处理函数就近定义
- 清晰的代码分区（初始化、核心业务、事件监听等）

```vue
<template>
  <div class="w-full h-full p-2 bg-transparent">
    <div class="...">
      <!-- 使用组件替代复杂的模板 -->
      <SearchHeader
        ref="searchHeaderRef"
        :height="headerHeight"
        :is-drag-over="isDragOver"
        :plugin-item="currentPluginItem"
        @search="handleSearch"
        @paste="handleFilePaste"
        ...
      />

      <ContentArea ... />
    </div>
  </div>
</template>
```

## 代码组织原则

### 1. 组件目录结构

```
components/
└── ComponentName/
    ├── ComponentName.vue          # 主组件
    ├── components/                # 子组件（如果需要）
    │   ├── SubComponent1.vue
    │   └── SubComponent2.vue
    └── hooks/                     # 组件特定的 hooks
        ├── useComponentState.ts
        └── useComponentLogic.ts
```

### 2. Hooks 放置规则

- **组件特定的 hooks**：放在组件目录的 `hooks/` 下
  - 例如：`SearchHeader/hooks/useSearchHeaderState.ts`
- **全局通用的 hooks**：放在 `src/renderer/src/composables/` 下
  - 例如：`composables/useWindowManager.ts`

### 3. 事件监听原则

- **直接注册**：在需要的地方直接使用 `naimo.event.onXxx()` 注册
- **避免包装**：不要创建多层包装函数，除非真的需要复用
- **就近定义**：事件处理函数定义在使用它的组件中

## 迁移指南

如果你需要添加新的事件监听：

### ❌ 不要这样做

```typescript
// 在 useAppEventHandlers.ts 中创建包装函数
const createXxxHandlers = (deps) => ({
  onXxx: () => { /* ... */ }
})

// 在 App.vue 中使用
const xxxHandlers = eventHandlers.createXxxHandlers({ ... })
```

### ✅ 应该这样做

```typescript
// 直接在 App.vue 中定义处理函数
const onXxx = () => {
  // 处理逻辑
};

// 直接注册
naimo.event.onXxx((event, data) => {
  onXxx();
});
```

如果逻辑复杂且需要复用，可以：

```typescript
// 在相关组件的 hooks 目录下创建
// components/YourComponent/hooks/useXxxHandler.ts
export function useXxxHandler() {
  const onXxx = () => {
    // 复杂的处理逻辑
  };

  return { onXxx };
}
```

## 后续优化建议

1. **ContentArea 组件拆分**
   - ContentArea 也比较复杂，可以考虑拆分为更小的组件
   - 建议结构：`ContentArea/components/CategoryList.vue`、`CategoryItem.vue` 等

2. **插件管理器优化**
   - 将 `usePluginWindowManager.ts` 中的逻辑进一步简化
   - 考虑是否需要创建专门的插件窗口组件

3. **搜索模块优化**
   - `modules/search/` 可以采用类似的目录结构
   - 将搜索相关的组件和 hooks 更好地组织

## 总结

本次重构遵循以下原则：

- ✅ **组件化**：将大组件拆分为小组件
- ✅ **就近原则**：相关代码放在一起
- ✅ **简化抽象**：移除不必要的包装层
- ✅ **清晰结构**：使用目录结构组织代码

通过这次重构，代码变得：

- 更易维护：每个组件职责单一
- 更易理解：事件流清晰，代码分区明确
- 更易扩展：新功能知道该放在哪里
