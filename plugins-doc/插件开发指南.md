# Naimo Tools 插件开发完整指南

> 版本：v2.0  
> 更新时间：2025-10-07  
> 架构：懒加载架构

## 📖 目录

- [简介](#简介)
- [快速开始](#快速开始)
- [插件结构](#插件结构)
- [配置文件详解](#配置文件详解)
- [功能类型详解](#功能类型详解)
- [Preload 脚本开发](#preload-脚本开发)
- [UI 页面开发](#ui-页面开发)
- [API 参考](#api-参考)
- [生命周期](#生命周期)
- [调试技巧](#调试技巧)
- [最佳实践](#最佳实践)
- [常见问题](#常见问题)

---

## 简介

Naimo Tools 采用**懒加载架构**，插件系统设计为轻量、灵活、易扩展。插件可以扩展应用的搜索功能，提供自定义的功能项。

### 核心特性

- ✅ **懒加载**：插件代码仅在需要时加载，提升性能
- ✅ **配置驱动**：通过 JSON 配置文件定义插件行为
- ✅ **多功能支持**：一个插件可以提供多个独立功能
- ✅ **类型安全**：提供完整的 TypeScript 类型定义
- ✅ **生命周期管理**：支持多种窗口生命周期模式

### 架构说明

**懒加载架构**是 Naimo Tools v2.0 的核心特性：

- **按需加载**：插件代码仅在功能被触发时加载，提升性能
- **配置与代码分离**：`manifest.json` 为纯 JSON 配置，功能处理器在 `preload.js` 中实现
- **统一管理**：`main` 和 `preload` 在插件顶层统一配置，所有 feature 共享

---

## 快速开始

### 创建你的第一个插件

#### 1. 创建插件目录

```bash
mkdir my-plugin
cd my-plugin
```

#### 2. 创建 `manifest.json`

```json
{
  "id": "my-plugin",
  "name": "我的插件",
  "version": "1.0.0",
  "author": "你的名字",
  "icon": "🎯",
  "description": "这是我的第一个插件",
  "category": "other",
  "enabled": true,
  "main": "./index.html",
  "preload": "./preload.js",
  "feature": [
    {
      "path": "hello",
      "name": "打招呼",
      "icon": "👋",
      "description": "向世界问好",
      "type": "text",
      "weight": 100,
      "lifecycleType": "reuse",
      "singleton": true
    }
  ]
}
```

#### 3. 创建 `preload.js`

```javascript
// 导出功能处理器
module.exports = {
  // 功能标识对应 manifest.json 中的 path
  hello: {
    onEnter: async (params) => {
      console.log("Hello World!");
      console.log("参数:", params);
      // 窗口会自动打开 main 指定的页面
      // 你可以在这里做一些初始化工作
    },
  },
};
```

#### 4. 创建 `index.html`

```html
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>我的插件</title>
    <style>
  <body>
    <div class="container">
      <h1>👋 Hello World!</h1>
      <p>欢迎使用我的第一个插件</p>
      <button onclick="logMessage()">测试日志</button>
    </div>
    <script>
      function logMessage() {
        // 使用 naimo 提供的日志 API
        window.naimo.log.info("Hello from plugin!");
      }
    </script>
  </body>
</html>
```

#### 5. 安装插件

将插件文件夹复制到 Naimo Tools 的 `plugins` 目录，然后重启应用。

#### 6. 测试插件

在搜索框中输入任意文本，你应该能看到"打招呼"这个选项。选择它即可触发插件。

---

## 插件结构

### 标准文件结构

```
my-plugin/
├── manifest.json      # 插件配置文件（必需）
├── preload.js        # Preload 脚本（必需）
├── index.html        # UI 页面（可选）
├── icon.png          # 插件图标（可选）
├── README.md         # 说明文档（推荐）
└── assets/           # 资源文件（可选）
    ├── styles/
    ├── scripts/
    └── images/
```

### 文件说明

#### manifest.json（必需）

插件的核心配置文件，定义插件的所有元数据和功能。

#### preload.js（必需）

Preload 脚本，在插件窗口创建时执行。主要用途：

1. 导出功能处理器（`module.exports`）
2. 暴露 API 到渲染进程（`contextBridge.exposeInMainWorld`）
3. 初始化插件环境

#### index.html（可选）

插件的 UI 页面。如果插件只提供后台功能（无 UI），可以不创建此文件。

---

## 配置文件详解

### manifest.json 完整说明

```json
{
  // ===== 基本信息（必需） =====
  "id": "my-plugin", // 插件唯一标识
  "name": "我的插件", // 插件名称
  "version": "1.0.0", // 版本号（语义化版本）
  "enabled": true, // 是否启用

  // ===== 作者信息（可选） =====
  "author": "你的名字", // 作者
  "icon": "🎯", // 插件图标（emoji 或图片路径）
  "description": "插件描述", // 插件描述

  // ===== 分类（可选） =====
  "category": "other", // 插件分类

  // ===== 下载地址（可选） =====
  "downloadUrl": "https://...", // 插件下载地址

  // ===== 插件级别配置（所有 feature 共用） =====
  "main": "./index.html", // UI 页面路径（可选）
  "preload": "./preload.js", // Preload 脚本路径（必需）

  // ===== 功能列表（必需） =====
  "feature": [
    {
      "path": "hello", // 功能标识
      "name": "打招呼", // 功能名称
      "type": "text", // 功能类型
      "icon": "👋", // 功能图标
      "description": "描述", // 功能描述
      "weight": 100, // 排序权重
      "lifecycleType": "reuse", // 生命周期类型
      "singleton": true // 是否单例
      // ... 其他配置
    }
  ],

  // ===== 自定义选项（可选） =====
  "options": {
    "customKey": "customValue"
  }

  // ===== 设置配置（可选，当前版本读写功能未实现） =====
  // "settings": [
  //   {
  //     "name": "apiKey",
  //     "title": "API 密钥",
  //     "type": "input",
  //     "defaultValue": "",
  //     "required": false
  //   }
  // ]
}
```

### 插件分类（category）

| 值                           | 名称       | 描述                      |
| ---------------------------- | ---------- | ------------------------- |
| `efficient_office`           | 高效办公   | 智能助手,轻松搞定办公琐事 |
| `ai_artificial_intelligence` | AI人工智能 | 与智能同行,赋能每一刻     |
| `developer_essentials`       | 程序员必备 | 让你更专注地改变世界      |
| `record_ideas`               | 记录想法   | 记录点滴灵感,创造无限可能 |
| `image_video`                | 图像视频   | 图片批量处理、屏幕录制    |
| `media_tools`                | 媒体工具   | 处理图片、视频等媒体文件  |
| `system_tools`               | 系统工具   | 提升系统效能,优化数字生活 |
| `study_well`                 | 好好学习   | 保持好奇心,不断探索新知   |
| `brainstorming`              | 脑洞大开   | 突破想象,启发奇思妙想     |
| `other`                      | 其他       | 其他类型的插件            |

---

## 功能类型详解

插件的每个功能项（feature）都必须指定一个类型（`type`），类型决定了功能的搜索匹配行为。

### 1. text - 文本搜索

匹配用户输入的文本内容，会搜索 `name`、`path`、`description`、`anonymousSearchFields` 字段。

```json
{
  "path": "text-processor",
  "name": "文本处理器",
  "type": "text",
  "description": "处理文本内容",
  "anonymousSearchFields": ["text", "处理", "编辑"],
  "minLength": 1, // 最小长度（可选）
  "maxLength": 1000 // 最大长度（可选）
}
```

**使用场景**：大多数插件功能，如搜索、查询、转换等。

---

### 2. regex - 正则匹配

使用正则表达式匹配用户输入。

```json
{
  "path": "url-opener",
  "name": "URL 打开器",
  "type": "regex",
  "match": "^https?://", // 正则匹配表达式（必需）
  "exclude": "^file://", // 排除表达式（可选）
  "minLength": 10, // 最小长度（可选）
  "maxLength": 2000 // 最大长度（可选）
}
```

**使用场景**：匹配特定格式的内容，如 URL、邮箱、电话号码等。

---

### 3. img - 图片搜索

匹配用户上传或粘贴的图片。

```json
{
  "path": "img-processor",
  "name": "图片处理器",
  "type": "img",
  "description": "处理图片"
}
```

**触发条件**：

- 用户通过截图功能获取图片
- 用户拖拽图片文件到搜索框
- 用户粘贴图片

**接收参数**：

```javascript
{
  type: "img",
  data: "data:image/png;base64,...",  // base64 图片数据
  originalFile: { /* 原始文件信息 */ }
}
```

---

### 4. files - 文件搜索

匹配用户拖拽的文件或文件夹。

```json
{
  "path": "file-counter",
  "name": "文件计数器",
  "type": "files",
  "fileType": "file", // 文件类型：file | directory
  "extensions": [".jpg", ".png"], // 文件扩展名（可选）
  "match": "^image_", // 文件名正则匹配（可选）
  "minLength": 1, // 最少文件数（可选）
  "maxLength": 100 // 最多文件数（可选）
}
```

**接收参数**：

```javascript
{
  type: "file",
  data: [
    {
      name: "example.jpg",
      path: "C:\\Users\\...",
      size: 1024,
      type: "file"  // file | directory
    }
  ]
}
```

---

### 功能配置通用字段

所有功能类型都支持以下字段：

| 字段                    | 类型     | 必需 | 说明                             |
| ----------------------- | -------- | ---- | -------------------------------- |
| `path`                  | string   | ✅   | 功能标识（英文，不带插件ID前缀） |
| `name`                  | string   | ✅   | 功能名称                         |
| `type`                  | string   | ✅   | 功能类型                         |
| `icon`                  | string   | ❌   | 功能图标                         |
| `description`           | string   | ❌   | 功能描述                         |
| `weight`                | number   | ❌   | 排序权重（0-1000，默认 0）       |
| `category`              | string   | ❌   | 功能分类                         |
| `platform`              | string[] | ❌   | 支持的平台                       |
| `anonymousSearchFields` | string[] | ❌   | 匿名搜索字段                     |
| `notVisibleSearch`      | boolean  | ❌   | 不在搜索框中主动显示             |
| `showInModes`           | string[] | ❌   | 显示模式限制                     |
| `lifecycleType`         | string   | ❌   | 生命周期类型                     |
| `singleton`             | boolean  | ❌   | 是否单例（默认 true）            |
| `autoStart`             | boolean  | ❌   | 是否开机启动                     |
| `recommend`             | boolean  | ❌   | 是否推荐                         |

---

## Preload 脚本开发

### 基本结构

```javascript
const { contextBridge } = require("electron");

// ==================== 工具函数 ====================

function myUtilFunction() {
  // 你的工具函数
}

// ==================== 暴露插件 API ====================

contextBridge.exposeInMainWorld("myPluginAPI", {
  // 暴露到渲染进程的 API
  doSomething: () => {
    // ...
  },
});

// ==================== 功能处理器导出 ====================

module.exports = {
  // 功能标识对应 manifest.json 中的 path
  hello: {
    onEnter: async (params, api) => {
      // 功能逻辑
    },
  },

  "another-feature": {
    onEnter: async (params, api) => {
      // 另一个功能的逻辑
    },
  },
};

// ==================== 初始化 ====================

window.addEventListener("DOMContentLoaded", () => {
  console.log("Preload 脚本已初始化");
});
```

### onEnter 钩子

每个功能处理器都必须提供 `onEnter` 钩子，该钩子在用户触发功能时被调用。

```javascript
{
  onEnter: async (params, api) => {
    // params: 触发参数
    // api: 插件 API
  };
}
```

#### params 参数说明

根据功能类型（`type`）的不同，`params` 的结构也不同：

##### text 类型

```javascript
{
  text: "用户输入的文本",
  mode: "text"
}
```

##### img 类型

```javascript
{
  type: "img",
  data: "data:image/png;base64,...",  // base64 图片
  originalFile: {
    name: "screenshot.png",
    path: "C:\\Users\\...",
    size: 1024
  }
}
```

##### files 类型

```javascript
{
  type: "file",
  data: [
    {
      name: "example.jpg",
      path: "C:\\Users\\...",
      size: 1024,
      type: "file"  // file | directory
    }
  ]
}
```

#### api 参数说明

`api` 对象预留用于未来扩展，当前版本暂无可用方法。

### 使用示例

```javascript
module.exports = {
  "text-processor": {
    onEnter: async (params, api) => {
      console.log("文本处理器被触发");

      // 获取用户输入的文本
      const text = params.text;

      // 处理文本
      const result = processText(text);

      // 显示结果（通过 UI 或通知）
      showResult(result);
    },
  },

  "file-counter": {
    onEnter: async (params, api) => {
      console.log("文件计数器被触发");

      // 获取文件列表
      const files = params.data;

      // 统计文件
      const stats = {
        total: files.length,
        totalSize: files.reduce((sum, f) => sum + f.size, 0),
      };

      // 显示统计结果
      console.log("文件统计:", stats);
    },
  },
};
```

### 暴露 API 到渲染进程

使用 `contextBridge.exposeInMainWorld` 暴露 API：

```javascript
const { contextBridge } = require("electron");

contextBridge.exposeInMainWorld("myPluginAPI", {
  // 同步方法
  getCurrentTime: () => {
    return new Date().toLocaleString();
  },

  // 异步方法
  fetchData: async (url) => {
    const response = await fetch(url);
    return response.json();
  },

  // 工具方法
  formatText: (text) => {
    return text.toUpperCase();
  },
});
```

在 HTML 中使用：

```javascript
// 调用暴露的 API
const time = window.myPluginAPI.getCurrentTime();
console.log("当前时间:", time);

// 异步调用
const data = await window.myPluginAPI.fetchData("https://api.example.com/data");
console.log("数据:", data);
```

---

## UI 页面开发

### 基本模板

```html
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>我的插件</title>
    <style>
      /* 你的样式 */
    </style>
  </head>
  <body>
    <div id="app">
      <!-- 你的内容 -->
    </div>

    <script>
      // 你的脚本
    </script>
  </body>
</html>
```

### 使用 Naimo API

插件窗口中可以使用 `window.naimo` 全局对象访问 Naimo 提供的 API。

#### 日志 API

```javascript
// 记录不同级别的日志
window.naimo.log.error("错误信息", errorObject);
window.naimo.log.warn("警告信息");
window.naimo.log.info("普通信息");
window.naimo.log.debug("调试信息");

// 抛出错误并显示错误对话框
window.naimo.log.throw_error(new Error("发生错误"), {
  title: "错误标题",
});
```

### 样式建议

推荐使用现代化的 CSS 样式：

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family:
    -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue",
    Arial, sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  padding: 20px;
  min-height: 100vh;
}

.container {
  background: white;
  border-radius: 16px;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
  padding: 40px;
  max-width: 800px;
  margin: 0 auto;
}

button {
  padding: 12px 24px;
  border: none;
  border-radius: 8px;
  background: #667eea;
  color: white;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

button:hover {
  background: #5568d3;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
}
```

---

## API 参考

### 插件 API（api 参数）

在 `onEnter` 钩子中提供的 `api` 参数当前版本暂无可用方法，预留用于未来扩展。

### Naimo API（window.naimo）

在 HTML 页面中可以通过 `window.naimo` 访问以下 API：

#### 日志 API

| 方法                                 | 说明                     |
| ------------------------------------ | ------------------------ |
| `log.error(message, ...args)`        | 记录错误日志             |
| `log.warn(message, ...args)`         | 记录警告日志             |
| `log.info(message, ...args)`         | 记录信息日志             |
| `log.debug(message, ...args)`        | 记录调试日志             |
| `log.throw_error(error, { title? })` | 抛出错误并显示错误对话框 |

---

## 生命周期

### 生命周期类型

插件功能支持三种生命周期类型（`lifecycleType`）：

#### 1. reuse（复用窗口，默认）

复用现有窗口。如果窗口已存在，则激活该窗口；否则创建新窗口。

```json
{
  "lifecycleType": "reuse",
  "singleton": true
}
```

**适用场景**：

- 单例功能（如设置页面）
- 需要保持状态的功能

#### 2. new（每次创建新窗口）

每次触发都创建新窗口。

```json
{
  "lifecycleType": "new",
  "singleton": false
}
```

**适用场景**：

- 需要同时打开多个实例的功能
- 每次处理独立的任务

#### 3. singleton（单例模式）

全局单例，同一时间只能存在一个窗口实例。

```json
{
  "lifecycleType": "singleton",
  "singleton": true
}
```

**适用场景**：

- 系统级功能
- 全局唯一的功能

### singleton 字段

`singleton` 字段决定是否启用单例模式：

- `true`（默认）：同时只能打开一个窗口
- `false`：可以同时打开多个窗口

---

## 调试技巧

### 1. 控制台输出

在 `preload.js` 和 HTML 中使用 `console.log` 或 `window.naimo.log` 输出调试信息：

```javascript
console.log("功能被触发，参数:", params);
window.naimo.log.info("功能被触发", params);
```

### 2. 打开开发者工具

在插件窗口中按 `F12` 或 `Ctrl+Shift+I` 打开开发者工具。

### 3. 查看网络请求

在开发者工具的 Network 标签中查看网络请求。

### 4. 断点调试

在开发者工具的 Sources 标签中设置断点。

### 5. 错误处理

使用 try-catch 捕获错误：

```javascript
onEnter: async (params, api) => {
  try {
    // 你的代码
  } catch (error) {
    console.error("错误:", error);
    // 显示错误通知
    new Notification("错误", {
      body: error.message,
    });
  }
};
```

---

## 最佳实践

### 1. 命名规范

- **插件 ID**：使用小写字母、数字、短横线，如 `my-plugin`
- **功能 path**：使用小写字母、数字、短横线，如 `hello-world`
- **设置名称**：使用驼峰命名法，如 `apiKey`、`enableNotification`

### 2. 版本管理

使用语义化版本号：

- `MAJOR.MINOR.PATCH`
- 如：`1.0.0`、`1.2.3`、`2.0.0-beta.1`

### 3. 错误处理

总是使用 try-catch 处理可能出错的代码：

```javascript
onEnter: async (params, api) => {
  try {
    // 可能出错的代码
  } catch (error) {
    console.error("错误:", error);
    // 显示用户友好的错误信息
  }
};
```

### 4. 性能优化

- 避免在 `onEnter` 中执行耗时操作
- 使用异步操作（`async/await`）
- 缓存计算结果

### 5. 用户体验

- 提供清晰的功能描述
- 使用友好的错误提示
- 添加加载状态指示
- 支持快捷键（如 `Ctrl+W` 关闭窗口）

### 6. 安全性

- 验证用户输入
- 避免执行不受信任的代码
- 小心处理文件路径

---

## 常见问题

### Q1: 插件没有出现在搜索结果中？

**A**: 检查以下几点：

1. `manifest.json` 格式是否正确
2. `enabled` 字段是否为 `true`
3. `feature` 数组是否至少包含一个功能
4. 插件文件夹是否在正确的 `plugins` 目录中
5. 重启应用

### Q2: 功能触发了，但窗口没有打开？

**A**: 检查以下几点：

1. `manifest.json` 中是否配置了 `main` 字段
2. `main` 指向的 HTML 文件是否存在
3. HTML 文件路径是否正确（相对于插件根目录）

### Q3: preload.js 中的代码没有执行？

**A**: 检查以下几点：

1. `manifest.json` 中 `preload` 字段是否正确
2. `preload.js` 文件是否存在
3. 是否有语法错误（查看控制台）
4. `module.exports` 格式是否正确

### Q4: 如何在功能之间共享数据？

**A**: 有几种方式：

1. 使用 `localStorage`（在 HTML 中）
2. 使用全局变量（在 preload.js 中）
3. 通过自定义的 contextBridge API 传递数据

### Q5: 如何处理文件上传？

**A**: 使用 `files` 类型功能，通过 `params.data` 获取文件列表：

```javascript
'file-handler': {
  onEnter: async (params, api) => {
    const files = params.data;
    files.forEach(file => {
      console.log('文件:', file.name, file.path);
    });
  }
}
```

### Q6: 如何发送网络请求？

**A**: 在 preload.js 或 HTML 中使用 `fetch` API：

```javascript
const response = await fetch("https://api.example.com/data");
const data = await response.json();
```

### Q7: 如何使用第三方库？

**A**: 有几种方式：

1. 在 HTML 中通过 `<script>` 标签引入 CDN
2. 将库文件放到插件目录中，然后引入
3. 在 preload.js 中 `require` Node.js 模块

### Q8: 插件设置在哪里配置？

**A**: 插件设置功能规划中，可在 `manifest.json` 的 `settings` 数组中声明设置项，但当前版本读写功能尚未实现。

### Q9: 如何调试插件？

**A**:

1. 在插件窗口中按 `F12` 打开开发者工具
2. 使用 `console.log` 输出调试信息
3. 在 Sources 标签中设置断点

### Q10: 插件可以访问文件系统吗？

**A**: 当前版本插件窗口中未暴露文件系统 API。如需访问文件系统，可以在 preload.js 中使用 Node.js 的 `fs` 模块，然后通过 `contextBridge` 暴露自定义 API 到渲染进程。

---

## 附录

### 示例插件

完整的示例插件请参考：

- `plugins-test/example-plugin/` - 完整示例
- `plugins/translate-plugin/` - 翻译插件示例
- `plugins/ocr-trans-plugin/` - OCR 翻译插件示例

### 相关文档

- [JSON Schema 文件](./manifest-schema.json)
- [快速开始指南](./quick-start.md)
- [API 参考文档](./api-reference.md)

### 变更日志

#### v2.0 (2025-10-07)

- 采用懒加载架构
- 配置文件纯 JSON 化
- 支持多功能插件
- 优化性能和加载速度

---

## 许可证

本文档采用 [MIT License](https://opensource.org/licenses/MIT)。

## 联系我们

如有问题或建议，请联系：

- GitHub Issues: https://github.com/naimo-tools/naimo-tools/issues
- Email: support@naimo.tools

---

**祝你开发愉快！** 🎉
