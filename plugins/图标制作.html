<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ICO å›¾æ ‡åˆ¶ä½œå·¥å…·</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js"></script>
  <style>
    @keyframes float {

      0%,
      100% {
        transform: translateY(0px) rotate(0deg);
      }

      50% {
        transform: translateY(-15px) rotate(5deg);
      }
    }

    .float-animation {
      animation: float 4s ease-in-out infinite;
    }

    @keyframes pulse-shadow {

      0%,
      100% {
        box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4);
      }

      50% {
        box-shadow: 0 0 0 20px rgba(59, 130, 246, 0);
      }
    }

    .pulse-shadow {
      animation: pulse-shadow 2s infinite;
    }
  </style>
</head>

<body class="overflow-hidden">
  <div id="app" class="h-screen">
    <!-- éšè—çš„æ–‡ä»¶è¾“å…¥æ¡†ï¼ˆå…¨å±€ï¼‰ -->
    <input ref="fileInput" type="file" @change="handleFileSelect" accept="image/*" class="hidden">

    <!-- ä¸Šä¼ é¡µé¢ - äº®è‰²é£æ ¼ -->
    <div v-if="currentStep === 'upload'"
      class="h-full bg-gradient-to-br from-blue-50 via-white to-cyan-50 flex items-center justify-center p-8">
      <div class="max-w-3xl w-full">
        <!-- ä¸Šä¼ å¡ç‰‡ -->
        <div class="bg-white rounded-3xl shadow-2xl p-10 border border-gray-100">
          <div @click="triggerFileInput" @dragover.prevent="isDragging = true" @dragleave.prevent="isDragging = false"
            @drop.prevent="handleDrop"
            :class="isDragging ? 'border-blue-500 bg-blue-50 scale-[1.02]' : 'border-gray-300'"
            class="border-3 border-dashed rounded-2xl p-16 cursor-pointer hover:border-blue-400 hover:bg-blue-50/50 transition-all duration-300 group">

            <div class="text-center">
              <!-- ä¸Šä¼ å›¾æ ‡ -->
              <div class="inline-block mb-6 transform group-hover:scale-110 transition-transform duration-300">
                <div class="bg-gradient-to-br from-blue-500 to-cyan-500 rounded-2xl p-6 shadow-lg pulse-shadow">
                  <svg class="w-16 h-16 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                      d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12">
                    </path>
                  </svg>
                </div>
              </div>

              <h3 class="text-3xl font-bold text-gray-800 mb-3">é€‰æ‹©æˆ–æ‹–æ‹½å›¾ç‰‡</h3>
              <p class="text-gray-500 mb-8 text-lg">æ”¯æŒ PNGã€JPGã€WEBP ç­‰å¸¸è§å›¾ç‰‡æ ¼å¼</p>

              <!-- ç‰¹æ€§åˆ—è¡¨ -->
              <div class="grid grid-cols-3 gap-6 max-w-2xl mx-auto">
                <div class="flex flex-col items-center gap-2">
                  <div class="bg-green-100 rounded-full p-3">
                    <svg class="w-6 h-6 text-green-600" fill="currentColor" viewBox="0 0 20 20">
                      <path fill-rule="evenodd"
                        d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z"
                        clip-rule="evenodd"></path>
                    </svg>
                  </div>
                  <span class="text-sm font-medium text-gray-700">æ™ºèƒ½è£å‰ª</span>
                </div>
                <div class="flex flex-col items-center gap-2">
                  <div class="bg-blue-100 rounded-full p-3">
                    <svg class="w-6 h-6 text-blue-600" fill="currentColor" viewBox="0 0 20 20">
                      <path fill-rule="evenodd"
                        d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z"
                        clip-rule="evenodd"></path>
                    </svg>
                  </div>
                  <span class="text-sm font-medium text-gray-700">åœ†è§’è°ƒèŠ‚</span>
                </div>
                <div class="flex flex-col items-center gap-2">
                  <div class="bg-cyan-100 rounded-full p-3">
                    <svg class="w-6 h-6 text-cyan-600" fill="currentColor" viewBox="0 0 20 20">
                      <path fill-rule="evenodd"
                        d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z"
                        clip-rule="evenodd"></path>
                    </svg>
                  </div>
                  <span class="text-sm font-medium text-gray-700">æ‰¹é‡å¯¼å‡º</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- åº•éƒ¨æç¤º -->
        <div class="text-center mt-8 flex items-center justify-center gap-2 text-gray-600">
          <svg class="w-5 h-5 text-blue-500" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd"
              d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z"
              clip-rule="evenodd"></path>
          </svg>
          <p class="text-sm">æç¤ºï¼šä¸Šä¼ å›¾ç‰‡åå¯ä»¥è‡ªç”±è£å‰ªå¹¶ç”Ÿæˆå¤šç§å°ºå¯¸çš„å›¾æ ‡</p>
        </div>
      </div>
    </div>

    <!-- å·¥ä½œé¡µé¢ -->
    <div v-if="currentStep === 'work'" class="h-full bg-gradient-to-br from-blue-50 to-indigo-100">
      <div class="grid grid-cols-1 lg:grid-cols-2 gap-4 h-full p-4">
        <!-- å·¦ä¾§ï¼šè£å‰ªåŒºåŸŸ -->
        <div class="bg-white rounded-xl shadow-xl p-5 flex flex-col overflow-hidden">
          <div class="flex items-center justify-between mb-3">
            <h2 class="text-lg font-bold text-gray-800">è£å‰ªè°ƒæ•´</h2>
            <button @click="triggerFileInput"
              class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors text-xs font-medium shadow-md flex items-center gap-2">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path>
              </svg>
              é‡æ–°ä¸Šä¼ å›¾ç‰‡
            </button>
          </div>

          <!-- æç¤ºä¿¡æ¯ -->
          <div class="mb-3 bg-blue-50 border border-blue-200 rounded-lg p-2">
            <p class="text-xs text-blue-800">
              ğŸ’¡ <strong>æ“ä½œæç¤ºï¼š</strong>è£å‰ªæ¡†å›ºå®šåœ¨ä¸­å¿ƒï¼Œè¯·æ‹–æ‹½ç§»åŠ¨å›¾ç‰‡æˆ–æ»šè½®ç¼©æ”¾å›¾ç‰‡æ¥è°ƒæ•´è£å‰ªåŒºåŸŸ
            </p>
          </div>

          <!-- è£å‰ªç”»å¸ƒ -->
          <div class="flex-1 mb-3 overflow-hidden">
            <img ref="cropperImage" :src="originalImage" class="max-w-full max-h-full">
          </div>

          <!-- åœ†è§’æ§åˆ¶ -->
          <div class="mb-3 bg-gray-50 rounded-lg p-3">
            <label class="block text-xs font-medium text-gray-700 mb-2">
              åœ†è§’åŠå¾„: {{ borderRadius }}%
            </label>
            <input v-model="borderRadius" type="range" min="0" max="50"
              class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer accent-blue-600">
            <div class="flex justify-between text-xs text-gray-500 mt-1">
              <span>ç›´è§’</span>
              <span>åœ†å½¢</span>
            </div>
          </div>

          <!-- é¢„è§ˆ -->
          <div class="text-center mb-3">
            <p class="text-xs font-medium text-gray-700 mb-2">å®æ—¶é¢„è§ˆ</p>
            <canvas ref="previewCanvas" width="120" height="120"
              class="mx-auto border-2 border-gray-300 rounded-lg shadow-sm"></canvas>
          </div>
        </div>

        <!-- å³ä¾§ï¼šç”ŸæˆåŒºåŸŸ -->
        <div class="bg-white rounded-xl shadow-xl p-5 flex flex-col overflow-hidden">
          <h2 class="text-lg font-bold text-gray-800 mb-3">ç”Ÿæˆå›¾æ ‡</h2>

          <!-- å°ºå¯¸é€‰æ‹© -->
          <div class="mb-4">
            <h3 class="text-sm font-semibold text-gray-700 mb-2">é€‰æ‹©éœ€è¦çš„å°ºå¯¸</h3>
            <div class="grid grid-cols-3 gap-2">
              <label v-for="size in availableSizes" :key="size"
                class="flex items-center space-x-2 p-2 border-2 rounded-lg cursor-pointer hover:bg-blue-50 transition-colors"
                :class="selectedSizes.includes(size) ? 'border-blue-500 bg-blue-50' : 'border-gray-300'">
                <input type="checkbox" :value="size" v-model="selectedSizes"
                  class="w-3 h-3 text-blue-600 rounded focus:ring-blue-500">
                <span class="text-xs font-medium text-gray-700">{{ size }}x{{ size }}</span>
              </label>
            </div>
            <button @click="toggleAllSizes" class="mt-2 text-xs text-blue-600 hover:text-blue-800 font-medium">
              {{ selectedSizes.length === availableSizes.length ? 'å–æ¶ˆå…¨é€‰' : 'å…¨é€‰' }}
            </button>
          </div>

          <!-- ç”Ÿæˆçš„å›¾æ ‡é¢„è§ˆ -->
          <div class="flex-1 overflow-hidden mb-4">
            <h3 class="text-sm font-semibold text-gray-700 mb-2">å›¾æ ‡é¢„è§ˆ</h3>
            <div class="grid grid-cols-3 gap-3 max-h-full overflow-y-auto pr-2">
              <div v-for="size in selectedSizes" :key="size" class="text-center">
                <div class="bg-gray-100 p-2 rounded-lg mb-1 flex items-center justify-center" style="min-height: 80px;">
                  <canvas :ref="el => { if (el) canvasRefs[size] = el }" :width="size" :height="size"
                    :style="{maxWidth: '60px', maxHeight: '60px', imageRendering: size <= 32 ? 'pixelated' : 'auto'}"
                    class="mx-auto"></canvas>
                </div>
                <p class="text-xs text-gray-600 font-medium mb-1">{{ size }}x{{ size }}</p>
                <button @click="downloadSingle(size)" class="text-xs text-blue-600 hover:text-blue-800">
                  ä¸‹è½½
                </button>
              </div>
            </div>
          </div>

          <!-- åº•éƒ¨æŒ‰é’® -->
          <div class="flex gap-2">
            <button @click="downloadAll"
              class="flex-1 px-4 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors font-medium shadow-md flex items-center justify-center gap-2">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
              </svg>
              <span class="text-sm">ä¸‹è½½å…¨éƒ¨</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const { createApp, ref, onMounted, onUnmounted, watch, nextTick } = Vue;

    createApp({
      setup() {
        // çŠ¶æ€ç®¡ç†
        const currentStep = ref('upload'); // 'upload', 'work'
        const isDragging = ref(false);
        const originalImage = ref(null);
        const borderRadius = ref(0);
        const fileInput = ref(null);
        const cropperImage = ref(null);
        const previewCanvas = ref(null);
        const canvasRefs = ref({});

        let cropper = null;
        let resizeObserver = null;
        let isDraggingImage = false;

        // å¯ç”¨å°ºå¯¸
        const availableSizes = ref([16, 24, 32, 48, 64, 96, 128, 256, 512, 1024]);
        const selectedSizes = ref([16, 32, 64, 128, 256]);

        // Debounce å‡½æ•°
        function debounce(func, wait) {
          let timeout;
          return function executedFunction(...args) {
            const later = () => {
              clearTimeout(timeout);
              func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
          };
        }

        // è§¦å‘æ–‡ä»¶é€‰æ‹©
        const triggerFileInput = () => {
          fileInput.value.click();
        };

        // å¤„ç†æ–‡ä»¶é€‰æ‹©
        const handleFileSelect = (event) => {
          const file = event.target.files[0];
          if (file && file.type.startsWith('image/')) {
            loadImage(file);
          }
        };

        // å¤„ç†æ‹–æ”¾
        const handleDrop = (event) => {
          isDragging.value = false;
          const file = event.dataTransfer.files[0];
          if (file && file.type.startsWith('image/')) {
            loadImage(file);
          }
        };

        // åŠ è½½å›¾ç‰‡
        const loadImage = (file) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            originalImage.value = e.target.result;
            currentStep.value = 'work';
            nextTick(() => {
              initCropper();
            });
          };
          reader.readAsDataURL(file);
        };

        // åˆå§‹åŒ–è£å‰ªå™¨
        const initCropper = () => {
          if (cropper) {
            cropper.destroy();
          }

          cropper = new Cropper(cropperImage.value, {
            aspectRatio: 1,
            viewMode: 1,
            dragMode: 'move',
            autoCropArea: 0.8,
            responsive: true,
            center: true,
            highlight: false,
            cropBoxMovable: false,
            cropBoxResizable: false,
            toggleDragModeOnDblclick: false,
            cropstart: () => {
              isDraggingImage = true;
            },
            cropend: () => {
              isDraggingImage = false;
              // åªåœ¨æ‹–æ‹½ç»“æŸæ—¶æ›´æ–°
              updatePreview();
            },
            zoom: debounceUpdatePreview // ç¼©æ”¾æ—¶ä½¿ç”¨debounce
          });

          // ç›‘å¬å®¹å™¨å°ºå¯¸å˜åŒ–
          setupResizeObserver();
        };

        // è®¾ç½® ResizeObserver ç›‘å¬å®¹å™¨å°ºå¯¸å˜åŒ–
        const setupResizeObserver = () => {
          if (resizeObserver) {
            resizeObserver.disconnect();
          }

          const container = cropperImage.value?.parentElement;
          if (!container) return;

          resizeObserver = new ResizeObserver(debounce(() => {
            if (cropper) {
              // é‡æ–°å±…ä¸­è£å‰ªæ¡†
              cropper.reset();
              updatePreview();
            }
          }, 1000));

          resizeObserver.observe(container);
        };

        // å¸¦ debounce çš„æ›´æ–°é¢„è§ˆï¼ˆç”¨äºç¼©æ”¾ï¼‰
        const debounceUpdatePreview = debounce(() => {
          if (!isDraggingImage) {
            updatePreview();
          }
        }, 1000);

        // æ›´æ–°é¢„è§ˆ
        const updatePreview = () => {
          if (!cropper || !previewCanvas.value) return;

          const canvas = cropper.getCroppedCanvas({
            width: 120,
            height: 120
          });

          if (!canvas) return;

          const ctx = previewCanvas.value.getContext('2d');
          ctx.clearRect(0, 0, 120, 120);

          // ä¿å­˜çŠ¶æ€
          ctx.save();

          // åº”ç”¨åœ†è§’
          if (borderRadius.value > 0) {
            const radius = (borderRadius.value / 100) * 60;
            ctx.beginPath();
            ctx.moveTo(radius, 0);
            ctx.lineTo(120 - radius, 0);
            ctx.quadraticCurveTo(120, 0, 120, radius);
            ctx.lineTo(120, 120 - radius);
            ctx.quadraticCurveTo(120, 120, 120 - radius, 120);
            ctx.lineTo(radius, 120);
            ctx.quadraticCurveTo(0, 120, 0, 120 - radius);
            ctx.lineTo(0, radius);
            ctx.quadraticCurveTo(0, 0, radius, 0);
            ctx.closePath();
            ctx.clip();
          }

          ctx.drawImage(canvas, 0, 0, 120, 120);
          ctx.restore();

          // åŒæ—¶ç”Ÿæˆå›¾æ ‡
          generateIcons();
        };

        // ç›‘å¬åœ†è§’å˜åŒ–ï¼ˆç«‹å³æ›´æ–°ï¼‰
        watch(borderRadius, () => {
          if (cropper) {
            updatePreview();
          }
        });

        // ç”Ÿæˆå›¾æ ‡
        const generateIcons = () => {
          if (!cropper) return;

          const canvas = cropper.getCroppedCanvas({
            width: 1024,
            height: 1024
          });

          if (!canvas) return;

          canvas.toBlob((blob) => {
            if (!blob) return;

            const reader = new FileReader();
            reader.onload = (e) => {
              const img = new Image();
              img.onload = () => {
                selectedSizes.value.forEach(size => {
                  const iconCanvas = canvasRefs.value[size];
                  if (!iconCanvas) return;

                  const ctx = iconCanvas.getContext('2d');
                  ctx.clearRect(0, 0, size, size);

                  // ä¿å­˜å½“å‰çŠ¶æ€
                  ctx.save();

                  // åº”ç”¨åœ†è§’
                  if (borderRadius.value > 0) {
                    const radius = (borderRadius.value / 100) * (size / 2);
                    ctx.beginPath();
                    ctx.moveTo(radius, 0);
                    ctx.lineTo(size - radius, 0);
                    ctx.quadraticCurveTo(size, 0, size, radius);
                    ctx.lineTo(size, size - radius);
                    ctx.quadraticCurveTo(size, size, size - radius, size);
                    ctx.lineTo(radius, size);
                    ctx.quadraticCurveTo(0, size, 0, size - radius);
                    ctx.lineTo(0, radius);
                    ctx.quadraticCurveTo(0, 0, radius, 0);
                    ctx.closePath();
                    ctx.clip();
                  }

                  ctx.drawImage(img, 0, 0, size, size);

                  // æ¢å¤çŠ¶æ€
                  ctx.restore();
                });
              };
              img.src = e.target.result;
            };
            reader.readAsDataURL(blob);
          });
        };

        // ç›‘å¬é€‰æ‹©çš„å°ºå¯¸å˜åŒ–
        watch(selectedSizes, () => {
          if (cropper) {
            nextTick(() => {
              generateIcons();
            });
          }
        }, { deep: true });

        // å…¨é€‰/å–æ¶ˆå…¨é€‰
        const toggleAllSizes = () => {
          if (selectedSizes.value.length === availableSizes.value.length) {
            selectedSizes.value = [];
          } else {
            selectedSizes.value = [...availableSizes.value];
          }
        };

        // ä¸‹è½½å•ä¸ªå›¾æ ‡
        const downloadSingle = (size) => {
          const canvas = canvasRefs.value[size];
          if (!canvas) return;

          const link = document.createElement('a');
          link.download = `icon-${size}x${size}.png`;
          link.href = canvas.toDataURL('image/png');
          link.click();
        };

        // ä¸‹è½½å…¨éƒ¨
        const downloadAll = () => {
          selectedSizes.value.forEach(size => {
            setTimeout(() => {
              downloadSingle(size);
            }, 100 * selectedSizes.value.indexOf(size));
          });
        };

        // è¿”å›ä¸Šä¼ é¡µé¢
        const backToUpload = () => {
          if (cropper) {
            cropper.destroy();
            cropper = null;
          }
          if (resizeObserver) {
            resizeObserver.disconnect();
            resizeObserver = null;
          }
          currentStep.value = 'upload';
          originalImage.value = null;
          borderRadius.value = 0;
          if (fileInput.value) {
            fileInput.value.value = '';
          }
        };

        // ç»„ä»¶å¸è½½æ—¶æ¸…ç†
        onUnmounted(() => {
          if (cropper) {
            cropper.destroy();
          }
          if (resizeObserver) {
            resizeObserver.disconnect();
          }
        });

        return {
          currentStep,
          isDragging,
          originalImage,
          borderRadius,
          fileInput,
          cropperImage,
          previewCanvas,
          canvasRefs,
          availableSizes,
          selectedSizes,
          triggerFileInput,
          handleFileSelect,
          handleDrop,
          toggleAllSizes,
          downloadSingle,
          downloadAll,
          backToUpload
        };
      }
    }).mount('#app');
  </script>
</body>

</html>